package com.smarttoolfactory.tutorial1_1basics.chapter3_layout

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.Stable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.Layout
import androidx.compose.ui.layout.Measurable
import androidx.compose.ui.layout.ParentDataModifier
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.Constraints
import androidx.compose.ui.unit.Density
import androidx.compose.ui.unit.dp
import com.smarttoolfactory.tutorial1_1basics.ui.components.StyleableTutorialText
import com.smarttoolfactory.tutorial1_1basics.ui.components.TutorialHeader
import com.smarttoolfactory.tutorial1_1basics.ui.components.TutorialText2

@Preview(showBackground = true)
@Composable
fun Tutorial3_3Screen1() {
    TutorialContent()
}

@Composable
private fun TutorialContent() {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .verticalScroll(rememberScrollState())
    ) {
        TutorialHeader(text = "Scope –∏ ParentDataModifier")
        StyleableTutorialText(
            text = "1) –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ scope –¥–ª—è Composable –¥–∞—ë—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å " +
                    "–¥–æ–±–∞–≤–ª—è—Ç—å –≤ –Ω—ë–º Modifier, –¥–æ—Å—Ç—É–ø–Ω—ã–π —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ–º scope. –ù–∞–ø—Ä–∏–º–µ—Ä, " +
                    "**Modifier.horizontalAlign** –¥–æ—Å—Ç—É–ø–µ–Ω —Ç–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–∏ **CustomColumnScope**."
        )

        TutorialText2(text = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è Column —Å–æ Scope")

        CustomColumnWithScope(
            modifier = Modifier
                .padding(8.dp)
                .fillMaxWidth()
                .background(Color.LightGray)
        ) {

            Text(
                "Align Start",
                modifier = Modifier
                    .background(Color(0xffF44336))
                    .horizontalAlign(HorizontalAlignment.Start),
                color = Color.White
            )
            Text(
                "Align Center",
                modifier = Modifier
                    .background(Color(0xff9C27B0))
                    .horizontalAlign(HorizontalAlignment.Center),
                color = Color.White
            )
            Text(
                "Align End",
                modifier = Modifier
                    .background(Color(0xff2196F3))
                    .horizontalAlign(HorizontalAlignment.End),
                color = Color.White
            )
            Text(
                "Align Start",
                modifier = Modifier
                    .background(Color(0xff8BC34A))
                    .horizontalAlign(HorizontalAlignment.Start),
                color = Color.White
            )
        }

        CustomColumnWithScope(
            modifier = Modifier
                .padding(8.dp)
                .fillMaxWidth()
                .height(250.dp)
                .background(Color.LightGray)
        ) {

            Text(
                "Align Start",
                modifier = Modifier
                    .background(Color(0xffF44336))
                    .horizontalAlign(HorizontalAlignment.Start),
                color = Color.White
            )
            Text(
                "Align Center",
                modifier = Modifier
                    .background(Color(0xff9C27B0))
                    .horizontalAlign(HorizontalAlignment.Center),
                color = Color.White
            )
            Text(
                "Align End",
                modifier = Modifier
                    .background(Color(0xff2196F3))
                    .horizontalAlign(HorizontalAlignment.End),
                color = Color.White
            )
            Text(
                "Align Start",
                modifier = Modifier
                    .background(Color(0xff8BC34A))
                    .horizontalAlign(HorizontalAlignment.Start),
                color = Color.White
            )
        }

        TutorialText2(text = "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è Row —Å–æ Scope")

        CustomRowWithScope(
            modifier = Modifier
                .padding(8.dp)
                .fillMaxWidth()
                .height(100.dp)
                .background(Color.DarkGray)
        ) {
            Text(
                "Align Top",
                modifier = Modifier
                    .background(Color(0xffF44336))
                    .verticalAlign(VerticalAlignment.Top),
                color = Color.White
            )
            Text(
                "Align Center",
                modifier = Modifier
                    .background(Color(0xff9C27B0))
                    .verticalAlign(VerticalAlignment.Center),
                color = Color.White
            )
            Text(
                "Align Bottom",
                modifier = Modifier
                    .background(Color(0xff2196F3))
                    .verticalAlign(VerticalAlignment.Bottom),
                color = Color.White
            )
        }
    }
}

// ------------------------------------------------------------------------------------------

/*
    ***** –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è Column *****
 */

/*
1) –°–æ–∑–¥–∞—ë–º enum –¥–ª—è –∑–∞–¥–∞–Ω–∏—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–≥–æ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è
 */
enum class HorizontalAlignment {
    Start, Center, End
}

/*
2) –°–æ–∑–¥–∞—ë–º –∫–ª–∞—Å—Å, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–π ParentDataModifier
 */
private class CustomColumnData(
    val alignment: HorizontalAlignment
) : ParentDataModifier {

    override fun Density.modifyParentData(parentData: Any?) = this@CustomColumnData

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        val otherModifier = other as? CustomColumnData ?: return false
        return alignment == otherModifier.alignment
    }

    override fun hashCode(): Int {
        return alignment.hashCode()
    }

    override fun toString(): String =
        "CustomColumnData(alignment=$alignment)"
}

/*
3) –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è Scope, –≥–¥–µ —Å–æ–∑–¥–∞—ë–º —Ñ—É–Ω–∫—Ü–∏—é-—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
   –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è ParentDataModifier
 */
interface CustomColumnScope {

    @Stable
    fun Modifier.horizontalAlign(align: HorizontalAlignment) = this.then(
        CustomColumnData(align)
    )

    companion object : CustomColumnScope
}

/*
4) –í Custom Layout –≤–Ω—É—Ç—Ä–∏ measurePolicy —Å—á–∏—Ç—ã–≤–∞–µ–º ParentData
   –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –¥–æ—á–µ—Ä–Ω–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤.
 */
private val Measurable.childData: CustomColumnData?
    get() = parentData as? CustomColumnData

private val Measurable.alignment: HorizontalAlignment
    get() = childData?.alignment ?: HorizontalAlignment.Start

@Composable
fun CustomColumnWithScope(
    modifier: Modifier = Modifier,
    content: @Composable CustomColumnScope.() -> Unit
) {

    Layout(
        modifier = modifier,
        content = { CustomColumnScope.content() },
    ) { measurables: List<Measurable>, constraints: Constraints ->

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º minWidth=0, —á—Ç–æ–±—ã Composable –∏–º–µ–ª–∏ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫—É—é —à–∏—Ä–∏–Ω—É –∫–æ–Ω—Ç–µ–Ω—Ç–∞
        val looseConstraints = constraints.copy(
            minWidth = 0,
            minHeight = 0
        )

        // –ò–∑–º–µ—Ä—è–µ–º –¥–µ—Ç–µ–π
        val placeables = measurables.map { measurable ->
            measurable.measure(looseConstraints)
        }

        val measurableAlignment: List<HorizontalAlignment> = measurables.map { measurable ->
            measurable.alignment
        }

        var yPosition = 0

        val totalHeight: Int = placeables.sumOf { it.height }
            .coerceAtLeast(constraints.minHeight)
        val maxWidth = constraints.maxWidth

        println(
            "ü§Ø Constraints minWidth: ${constraints.minWidth}, " +
                    "minHeight: ${constraints.minHeight}, " +
                    "maxWidth: ${constraints.maxWidth}, " +
                    "maxHeight: ${constraints.maxHeight}, " +
                    "totalHeight: $totalHeight"
        )

        // –ó–∞–¥–∞—ë–º —Ä–∞–∑–º–µ—Ä—ã –ª–µ–π–∞—É—Ç–∞
        layout(maxWidth, totalHeight) {
            // –†–∞–∑–º–µ—â–∞–µ–º –¥–æ—á–µ—Ä–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã
            placeables.forEachIndexed { index, placeable ->
                val x = when (measurableAlignment[index]) {
                    HorizontalAlignment.Start -> 0
                    HorizontalAlignment.Center -> (maxWidth - placeable.width) / 2
                    HorizontalAlignment.End -> maxWidth - placeable.width
                }

                placeable.placeRelative(x = x, y = yPosition)
                yPosition += placeable.height
            }
        }
    }
}

// ------------------------------------------------------------------------------------------

/*
    ***** –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è Row *****
 */

/*
1) –°–æ–∑–¥–∞—ë–º enum –¥–ª—è –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–≥–æ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è
 */
enum class VerticalAlignment {
    Top, Center, Bottom
}

/*
2) –°–æ–∑–¥–∞—ë–º –∫–ª–∞—Å—Å, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–π ParentDataModifier
 */
private class CustomRowData(
    val alignment: VerticalAlignment
) : ParentDataModifier {

    override fun Density.modifyParentData(parentData: Any?) = this@CustomRowData

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        val otherModifier = other as? CustomRowData ?: return false
        return alignment == otherModifier.alignment
    }

    override fun hashCode(): Int {
        return alignment.hashCode()
    }

    override fun toString(): String =
        "CustomRowData(alignment=$alignment)"
}

/*
3) –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è Scope, –≥–¥–µ —Å–æ–∑–¥–∞—ë–º —Ñ—É–Ω–∫—Ü–∏—é-—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ
   –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è ParentDataModifier
 */
interface CustomRowScope {

    @Stable
    fun Modifier.verticalAlign(align: VerticalAlignment) = this.then(
        CustomRowData(align)
    )

    companion object : CustomRowScope
}

/*
4) –°—á–∏—Ç—ã–≤–∞–µ–º ParentData –≤ Custom Layout –ø—Ä–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏–∏
 */
private val Measurable.data: CustomRowData?
    get() = parentData as? CustomRowData

private val Measurable.verticalAlignment: VerticalAlignment
    get() = data?.alignment ?: VerticalAlignment.Center

@Composable
fun CustomRowWithScope(
    modifier: Modifier = Modifier,
    content: @Composable CustomRowScope.() -> Unit
) {

    Layout(
        modifier = modifier,
        content = { CustomRowScope.content() },
    ) { measurables: List<Measurable>, constraints: Constraints ->

        val looseConstraints = constraints.copy(
            minWidth = 0,
            minHeight = 0
        )

        val placeables = measurables.map { measurable ->
            measurable.measure(looseConstraints)
        }

        val measurableAlignment: List<VerticalAlignment> = measurables.map { measurable ->
            measurable.verticalAlignment
        }

        val totalWidth: Int = placeables.sumOf { it.width }
            .coerceAtLeast(constraints.minWidth)

        var maxHeight: Int = if (constraints.hasBoundedHeight) constraints.maxHeight
        else placeables.maxOf { it.height }.coerceAtLeast(constraints.minHeight)

        println(
            "üß® Constraints minWidth: ${constraints.minWidth}, " +
                    "minHeight: ${constraints.minHeight}, " +
                    "maxWidth: ${constraints.maxWidth}, " +
                    "maxHeight: ${constraints.maxHeight}, " +
                    "totalWidth: ${totalWidth}, " +
                    "height: $maxHeight"
        )

        var xPosition = 0

        layout(totalWidth, maxHeight) {
            placeables.forEachIndexed { index, placeable ->
                val y = when (measurableAlignment[index]) {
                    VerticalAlignment.Top -> 0
                    VerticalAlignment.Center -> (maxHeight - placeable.height) / 2
                    VerticalAlignment.Bottom -> maxHeight - placeable.height
                }
                placeable.placeRelative(x = xPosition, y = y)
                xPosition += placeable.width
            }
        }
    }
}